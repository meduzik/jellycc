[terminals]

import: KImport;

identifier: Identifier;

decimal_lit: Decimal;
float_lit: Float;
hex_lit: Hex;
bin_lit: Bin;

comment: Comment {skip};
ml_comment: MLComment {skip};

string_lit: String;

"(": LParen;
")": RParen;
"[": LBracket;
"]": RBracket;
"{": LBrace;
"}": RBrace;

"#": OpHash;

"=": OpAssign;
"+=": OpPlusAssign;
"-=": OpMinusAssign;
"*=": OpMulAssign;
"/=": OpDivAssign;
"%=": OpModAssign;
"&=": OpAndAssign;
"|=": OpOrAssign;
"^=": OpXorAssign;
"<<=": OpShlAssign;
">>=": OpAShrAssign;
">>>=": OpLShrAssign;

"++": OpIncr;
"--": OpDecr;

"+": OpPlus;
"-": OpMinus;
"*": OpMul;
"/": OpDiv;
"%": OpMod;
"~": OpNeg;
"&": OpBitAnd;
"|": OpBitOr;
"||": OpLogicalOr;
"&&": OpLogicalAnd;
"^": OpBitXor;
"<<": OpShl;
">>": OpAShr;
">>>": OpLShr;

"==": OpEQ;
"!=": OpNEQ;
"<": OpLT;
">": OpGT;
"<=": OpLE;
">=": OpGE;

"->": OpArrow;
".": OpDot;
",": OpComma;
":": OpColon;
";": OpSemi;
"?": OpQuestion;

eof: "EoF" {eof};
space: "Space" {skip};
error: "Error" {error};


[lexer.fragments]

digit:          [0-9];
non_zero_digit: [1-9];
l_letter:       [a-z];
U_letter:       [A-Z];
letter:         [a-zA-Z];
space:          [ \n\r\t];
whitespace:     [ \t];
newline:        [\n]|[\r\n]|[\r];
id_start_char:  <letter> | _;
id_char:        <letter> | <digit> | _;
integer:        0 | <non_zero_digit> <digit>* (\'<digit>+)*;
hex_digit:      [0-9a-fA-F];

[lexer.grammar]

import;

identifier:     <id_start_char> <id_char>*;

decimal_lit:        <integer>;
float_lit:          <integer> [.] <digit>+ (\'<digit>+)* ([eE][+\-]?[0-9]+(\'[0-9]+)*)?;
hex_lit:            0x <hex_digit>+(\'<hex_digit>+)*;
bin_lit:            0b [01]+(\'[0-1]+)*;

space:          (" "|\r\n|\n|\r|\t)+;

comment:        "//" [^\n\r]+ <newline>?;
ml_comment:     "/*" ([^*]|[*]*[^/*])* [*]* "*/";

string_lit:         \" ( \\[nrt0\\"] | \\x <hex_digit>{2} | [^"\\] )* \";
string_lit:         \' ( \\[nrt0\\'] | \\x <hex_digit>{2} | [^'\\] )* \';

"(";
")";
"[";
"]";
"{";
"}";

"#";

"&&";
"||";

"=";
"+=";
"-=";
"*=";
"/=";
"%=";
"&=";
"|=";
"^=";
"<<=";
">>=";
">>>=";

"++";
"--";

"+";
"-";
"*";
"/";
"%";
"~";
"&";
"|";
"^";
"<<";
">>";
">>>";

"==";
"!=";
"<";
">";
"<=";
">=";

"->";
".";
",";
":";
";";
"?";

[parser.expose]

S;

[parser.types]

S: "int";
#param_list: "List<int>*";
vardef: "int";

[parser.grammar]

S: {nullptr};
S: S vardef {nullptr};

#vardef: identifier '=' e ';' {writevar($identifier,$e)};
vardef: identifier ';' {writevar($identifier)};



# S: e {$e};

# e: e '+' f {$e + $f};
# e: e '-' f {$e - $f};
# e: f;
# f: f '*' t {$f * $t};
# f: f '/' t {$f / $t};
# f: t;
# t: '(' e ')' {$e};
# t: identifier '(' param_list ')' {exec($identifier, $param_list)};
# t: decimal_lit {atoi($decimal_lit)};
# t: identifier {var($identifier)};
#
# param_list: {nullptr};
# param_list: param_list_head;
# param_list_head: e {new List<int>($e, nullptr)};
# param_list_head: param_list_head ',' e {new List<int>($param_list_head, $e)};
#
#